/**
 * @file rtc_driver.c
 * @brief RTC Driver Wrapper Implementation
 */

#include "rtc_driver.h"
#include <stdio.h>
#include <string.h>

/* Extern the handle generated by CubeMX */
#ifdef HAL_RTC_MODULE_ENABLED
extern RTC_HandleTypeDef hrtc;
#endif

#ifdef HAL_RTC_MODULE_ENABLED

// Helper: Convert time_t (Unix) to HAL Date/Time
// Note: STM32F1 RTC is a simple Counter. The HAL driver for F1 usually
// handles the conversion if using the specific 'RTC_DateTypeDef', OR
// for F1, the hardware only counts seconds (Counter).
// HAL_RTC_Init usually sets up the Prescaler.
// 
// IMPORTANT: STM32F1 HAL's `HAL_RTC_GetTime` returns the Counter value directly
// if we look at the implementation? No, on F1 it usually fills the TimeStruct.
// But F1 RTC HARDWARE is just a 32-bit counter. The HAL helper functions
// do software calculation for Date/Time.
//
// However, the standard `time.h` functions `gmtime` and `mktime` are perfect for this.

/* Since F1 Hardware IS a timestamp counter (mostly), we can direct access or use HAL helpers.
   But HAL implementations for F1 often use a "Store Date in Backup Register" Hack
   because the counter is just 32-bit seconds, but 0 is usually not 1970.
   Often 0 is Reset.
   Let's assume the Counter represents Unix Timestamp directly for simplicity.
*/

bool RTC_SetTimeUnix(uint32_t timestamp) {
    // HAL_RTC_SetCounter writes to the 32-bit CNT registers
    // We treat this counter as Unix Epoch.
    /* 
       Note: 32-bit unsigned max is year 2106.
    */
    if (HAL_RTCEx_SetSecond_IT(&hrtc) != HAL_OK) {
       // Just to ensure handle is valid?
    }
    
    // We can use the Low Level macro or HAL function if available.
    // HAL_IO_Write(RTC_CNTH/L)
    // Actually `HAL_RTC_SetCounter` is not always available in all HAL versions?
    // Let's check stm32f1xx_hal_rtc.h or similar.
    // It's usually legacy or specific.
    
    // Standard HAL usage for F1 SetTime:
    // It takes a RTC_TimeTypeDef. It calculates the offset from today start?
    // This is messy in ST HAL for F1.
    
    // DIRECT REGISTER ACCESS IS EASIER for F1 RTC (Simpler Hardware)
    // But we should try to use HAL.
    
    /* 
       Wait, for F1, HAL_RTC_SetTime(hrtc, &sTime, Format) sets the counter
       based on sTime.Hours/Min/Sec.
       But it ignores Date!
       So `RTC_GetDate` on F1 is software emulated often requiring Backup Domain storage.
    */

    /* APPROACH:
       We will treat the 32-bit RTC Counter as the MASTER Source of Truth for Unix Time.
       We will IGNORE HAL_RTC_SetTime/GetTime structured functions because they are confusing on F1.
       We update the Counter register directly using the Handle helper.
    */
    
    // Enable Write Access
    PWR->CR |= PWR_CR_DBP;
    
    // Wait for Synchro
    // HAL_RTC_WaitForSynchro(&hrtc); // Already in Init usually
    
    // Enter Init Mode to write counter
    // For F1, we just write to CNT.
    // USE HAL Helper:
    /* 
       There isn't a simple "SetCounter". 
       We must use: WRITE_REG(hrtc.Instance->CNTH, (timestamp >> 16));
                    WRITE_REG(hrtc.Instance->CNTL, (timestamp & 0xFFFF));
       But we need to be in Config Mode (RTOFF).
    */

    // Let's use `__HAL_RTC_WRITEPROTECTION_DISABLE` ? No F1 doesn't have that lock same way.
    
    // Using the pointer directly:
    RTC_TypeDef *rtc = hrtc.Instance;
    
    // 1. Poll RTOFF (Last write finished)
    uint32_t timeout = 0;
    while (!(rtc->CRL & RTC_CRL_RTOFF)) {
        if (++timeout > 0xFFFF) return false;
    }
    
    // 2. Enter Config Mode
    rtc->CRL |= RTC_CRL_CNF;
    
    // 3. Write
    rtc->CNTH = (timestamp >> 16);
    rtc->CNTL = (timestamp & 0xFFFF);
    
    // 4. Exit Config Mode
    rtc->CRL &= ~RTC_CRL_CNF;
    
    // 5. Wait for write to finish
    while (!(rtc->CRL & RTC_CRL_RTOFF));
    
    return true;
}

uint32_t RTC_GetTimeUnix(void) {
    RTC_TypeDef *rtc = hrtc.Instance;
    
    // Read Counter
    // Note: If CNTL is read, it might tick over before CNTH is read?
    // Manual says: Read CNTL first, then CNTH? Or read twice?
    // For F1: "The software must read the RTC_CNTL register first, then the RTC_CNTH"
    
    uint16_t low = (uint16_t)rtc->CNTL;
    uint16_t high = (uint16_t)rtc->CNTH;
    
    return ((uint32_t)high << 16) | low;
}

void RTC_GetTimeString(char *buffer) {
    if (!buffer) return;
    
    time_t now = (time_t)RTC_GetTimeUnix();
    struct tm *t = localtime(&now);
    
    // t->tm_year is years since 1900
    // t->tm_mon is 0-11
    sprintf(buffer, "%04d-%02d-%02d %02d:%02d:%02d",
            t->tm_year + 1900,
            t->tm_mon + 1,
            t->tm_mday,
            t->tm_hour,
            t->tm_min,
            t->tm_sec);
}

bool RTC_IsReady(void) {
    return (HAL_RTC_GetState(&hrtc) == HAL_RTC_STATE_READY);
}

#else

// Stubs
bool RTC_SetTimeUnix(uint32_t timestamp) { return false; }
uint32_t RTC_GetTimeUnix(void) { return 0; }
void RTC_GetTimeString(char *buffer) { if(buffer) strcpy(buffer, "RTC_DISABLED"); }
bool RTC_IsReady(void) { return false; }

#endif
