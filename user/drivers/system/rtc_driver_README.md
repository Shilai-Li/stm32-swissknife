# RTC Driver Module

This module provides a clean, thread-safe RTC driver wrapper for STM32 microcontrollers with Unix timestamp support and explicit dependency injection.

## Features
- **Unix Timestamp Support**: Set and get time using standard Unix epoch (seconds since 1970-01-01).
- **Thread-Safe**: Critical sections protect 32-bit register access from race conditions.
- **Dependency Injection**: Explicit `RTC_Register()` call - no hardcoded hardware dependencies.
- **Cross-Series Compatible**: Auto-detects STM32F1/F4/F7/H7/etc HAL libraries.
- **Formatted Output**: Built-in `RTC_GetTimeString()` for human-readable timestamps.

## CubeMX Configuration Requirements

To use this driver, you **MUST** configure the RTC peripheral in STM32CubeMX:

1.  **RTC** (Timers → RTC):
    *   **Activated**: ☑ Checked
    *   **Clock Source**: LSE (32.768kHz Crystal) - **Recommended** for accuracy
        *   Alternative: LSI (Internal ~40kHz) - Less accurate but no external crystal needed
    
2.  **Clock Configuration** Tab:
    *   Enable **LSE** in RCC settings
    *   Set **RTC Clock Mux** → **LSE**

3.  **Calendar** (Optional):
    *   You can set default Date/Time in CubeMX, but this driver will overwrite it on first `RTC_SetTimeUnix()` call.

**Note for STM32F1**: The hardware RTC is a simple 32-bit counter. This driver treats it directly as a Unix timestamp (seconds since 1970). The HAL's Date/Time struct is bypassed for simplicity.

## Usage Guide

### 1. Register the RTC Handle (Dependency Injection)
In your initialization code (e.g., `app_main` or `main.c` after `MX_RTC_Init()`):

```c
#include "rtc_driver.h"
#include "rtc.h" // Provides hrtc (generated by CubeMX)

void app_main(void) {
    // Register the HAL RTC handle
    RTC_Register(&hrtc);
    
    // Check if RTC is ready
    if (!RTC_IsReady()) {
        // Handle error: RTC initialization failed
    }
}
```

### 2. Setting Time
```c
// Set time to 2025-01-01 00:00:00 UTC
// You can use online Unix timestamp converters or calculate programmatically
uint32_t timestamp = 1735689600; // 2025-01-01 00:00:00 UTC

if (RTC_SetTimeUnix(timestamp)) {
    // Success
} else {
    // Timeout or error
}
```

### 3. Reading Time
```c
// Get Unix Timestamp
uint32_t now = RTC_GetTimeUnix();
printf("Current Unix Time: %u\n", now);

// Get Formatted String
char time_str[20]; // Must be at least 20 bytes
RTC_GetTimeString(time_str);
printf("Current Time: %s\n", time_str); // Output: "2025-01-01 00:00:05"
```

### 4. Using Alarm Callbacks (Future Enhancement)
```c
void MyAlarmHandler(void) {
    // Called when RTC alarm triggers
    printf("Wake up!\n");
}

RTC_SetAlarmCallback(MyAlarmHandler);
// Note: Alarm configuration not yet implemented in this version
```

## API Reference

### Initialization
```c
void RTC_Register(RTC_HandleTypeDef *hrtc);
```
Register the RTC hardware handle. **Must be called before any other RTC functions.**

### Time Management
```c
bool RTC_SetTimeUnix(uint32_t timestamp);
```
Set RTC time using Unix timestamp. Returns `true` on success, `false` on timeout.

```c
uint32_t RTC_GetTimeUnix(void);
```
Get current RTC time as Unix timestamp. Returns `0` if RTC not registered.

```c
void RTC_GetTimeString(char *buffer);
```
Get formatted time string in ISO-8601 format: `"YYYY-MM-DD HH:MM:SS"`. Buffer must be at least 20 bytes.

### Status
```c
bool RTC_IsReady(void);
```
Check if RTC hardware is initialized and ready.

### Callbacks
```c
void RTC_SetAlarmCallback(RTC_AlarmCallback cb);
```
Set callback for alarm events (reserved for future alarm functionality).

## Troubleshooting

### RTC Not Incrementing?
1.  **Check LSE Clock**: Ensure LSE crystal (32.768kHz) is properly connected with correct load capacitors (typically 12-22pF).
2.  **Check Backup Domain Power**: `PWR_CR_DBP` bit must be set to allow writes to RTC (handled internally by driver).
3.  **Check Battery**: If using VBAT pin, ensure backup battery is connected and charged.

### Wrong Time After Reset?
*   **Power Loss**: RTC loses time if VBAT is not connected and main power is removed.
*   **First Boot**: After firmware flash, RTC counter is reset. Call `RTC_SetTimeUnix()` to initialize.

### Time Drifts Over Days?
*   **LSI Accuracy**: If using LSI instead of LSE, expect ~±5% drift. Switch to LSE for better accuracy.
*   **Temperature**: LSE crystals have ~±20ppm accuracy at room temperature.

## Running Tests

A comprehensive test suite is provided in `user/drivers/system/rtc_driver_tests.c`.

### Test Flow
1.  Registers RTC handle
2.  Sets known timestamp (2025-01-01 00:00:00)
3.  Reads back time every second for 10 iterations
4.  Verifies time increments correctly
5.  Prints formatted timestamps

### Expected Output
```
===================================
     RTC Driver Test Suite       
===================================
RTC Status: READY
Setting Time: 2025-01-01 00:00:00 (Unix: 1735689600)

[1] Unix: 1735689601 | Time: 2025-01-01 00:00:01 | Delta: +1s ✓
[2] Unix: 1735689602 | Time: 2025-01-01 00:00:02 | Delta: +1s ✓
[3] Unix: 1735689603 | Time: 2025-01-01 00:00:03 | Delta: +1s ✓
...
=== All Tests PASSED ===
```

## Release Notes (2025-12)

### Enhancements (Golden Template Alignment)
- **Dependency Injection**: Added `RTC_Register()` - no more hardcoded `extern hrtc`.
- **Thread Safety**: Critical sections (`__disable_irq()`) protect 32-bit counter read/write operations.
- **Callback Infrastructure**: Added `RTC_SetAlarmCallback()` for future alarm support.
- **Robustness**: Added null pointer checks and timeout protection in `RTC_SetTimeUnix()`.
- **Simplified Implementation**: Direct register access for F1 series (cleaner than HAL Date/Time structs).

### Breaking Changes
- **Registration Required**: You must now call `RTC_Register(&hrtc)` before using any RTC functions.
