# Watchdog Driver Module

This module provides a simple, safe wrapper for the STM32 Independent Watchdog (IWDG) with automatic prescaler calculation and explicit dependency injection.

## Features
- **Auto-Calculation**: Automatically calculates prescaler and reload values from desired timeout in milliseconds.
- **Dependency Injection**: Explicit `Watchdog_Register()` call - no hardcoded dependencies.
- **Reset Detection**: Check if the last reset was caused by watchdog timeout.
- **Fallback Safe**: Uses internal handle if no external handle registered (backward compatible).
- **Cross-Series Compatible**: Works with STM32F1/F4/F7/H7/etc.

## ⚠️ Important Warnings

1.  **Cannot Be Stopped**: Once `Watchdog_Init()` is called, the watchdog **CANNOT** be disabled until a system reset occurs!
2.  **Must Feed Regularly**: You **MUST** call `Watchdog_Feed()` before the timeout expires, or the MCU will reset.
3.  **Debug Mode**: By default, IWDG continues running during debug halt. Configure `DBGMCU` in CubeMX to pause it during debug if needed.

## CubeMX Configuration Requirements

1.  **IWDG** (System Core → IWDG):
    *   **Activated**: ☑ Checked
    *   **Parameters**: You can leave defaults - **this driver will recalculate and overwrite them** based on your `timeout_ms` argument.

2.  **Debug Options** (Optional):
    *   `DBGMCU_APB1_FZ` → `DBG_IWDG_STOP`: Check this to pause watchdog during debug breakpoints.

**Note**: LSI (Low Speed Internal oscillator, ~40kHz but varies 30-60kHz) is automatically enabled when IWDG is activated.

## Usage Guide

### 1. Register the IWDG Handle (Optional but Recommended)
In your initialization code:

```c
#include "watchdog.h"
#include "iwdg.h" // Provides hiwdg (generated by CubeMX)

void app_main(void) {
    // Register the HAL IWDG handle (optional - driver has internal fallback)
    Watchdog_Register(&hiwdg);
}
```

**Note**: If you don't call `Watchdog_Register()`, the driver uses an internal static handle. Registration is recommended for consistency with other drivers.

### 2. Initialize Watchdog
```c
// Set timeout to 5 seconds (5000ms)
if (Watchdog_Init(5000)) {
    printf("Watchdog started: 5s timeout\n");
} else {
    printf("Error: Timeout too long (max ~32s)\n");
}

// WARNING: From this point, you MUST call Watchdog_Feed() every <5s!
```

### 3. Feed the Watchdog
Call this periodically in your main loop or RTOS task:

```c
while (1) {
    // Your application code...
    
    Watchdog_Feed(); // Reset watchdog timer
    
    HAL_Delay(1000); // Must be less than timeout!
}
```

### 4. Detect Watchdog Reset
Check on boot to see if the last reset was caused by watchdog:

```c
void app_main(void) {
    if (Watchdog_WasResetByDog()) {
        printf("WARNING: System recovered from watchdog reset!\n");
        // Log error, enter safe mode, etc.
    }
    
    Watchdog_Init(5000);
}
```

## API Reference

### Initialization
```c
void Watchdog_Register(IWDG_HandleTypeDef *hiwdg);
```
Register the IWDG hardware handle. Optional - driver has internal fallback.

```c
bool Watchdog_Init(uint32_t timeout_ms);
```
Initialize and start the watchdog with specified timeout in milliseconds.
- **Range**: ~4ms to ~32000ms (depends on LSI frequency).
- **Returns**: `true` on success, `false` if timeout out of range.
- **Warning**: Cannot be stopped after this call!

### Runtime
```c
void Watchdog_Feed(void);
```
Reload watchdog counter (pet the dog). Must be called before timeout expires.

### Status
```c
bool Watchdog_WasResetByDog(void);
```
Check if the last system reset was caused by IWDG timeout. Automatically clears the flag after reading.

## Timeout Calculation Details

The driver automatically selects the optimal prescaler from available values:
*   Prescaler: 4, 8, 16, 32, 64, 128, 256
*   Reload: 1-4095 (12-bit counter)
*   Formula: `Timeout = (Prescaler × Reload) / LSI_Freq`

### Examples (assuming LSI = 40kHz):
| Timeout (ms) | Prescaler | Reload | Actual Timeout |
|--------------|-----------|--------|----------------|
| 100          | 4         | 1000   | 100.0ms        |
| 1000         | 32        | 1250   | 1000.0ms       |
| 5000         | 128       | 1563   | 5001.6ms       |
| 32000        | 256       | 5000   | 32000ms        |

**Accuracy Note**: LSI varies ±47% across temperature and voltage. For precise timing, use an external RTC or SysTick.

## Troubleshooting

### Immediate Resets?
1.  **Not Feeding**: Ensure `Watchdog_Feed()` is called in main loop **before** timeout expires.
2.  **Blocking Code**: Check for `HAL_Delay()` or blocking functions that exceed timeout.
3.  **RTOS Issues**: If using FreeRTOS, ensure watchdog task has sufficient priority and CPU time.

### Reset Flag Not Set?
*   **Other Reset Source**: Check `__HAL_RCC_GET_FLAG()` for other flags (NRST, Software Reset, etc.).
*   **Flag Already Cleared**: `Watchdog_WasResetByDog()` clears the flag after reading - call it only once at startup.

### Watchdog Doesn't Trigger?
*   **Debug Mode**: If `DBG_IWDG_STOP` is enabled, watchdog pauses during debug. Disable this or run without debugger.
*   **Wrong Init Sequence**: Ensure `Watchdog_Init()` actually executes (check return value).

## Running Tests

A comprehensive test suite is provided in `user/drivers/system/watchdog_tests.c`.

### Test Flow
1.  Checks if last reset was watchdog-caused
2.  Initializes watchdog with 2-second timeout
3.  Feeds watchdog 10 times (once per second)
4.  **Intentionally stops feeding** to trigger reset
5.  After reset, detects and confirms watchdog recovery

### Expected Output
```
===================================
   Watchdog Driver Test Suite    
===================================

--- Test 1: Reset Detection ---
Last Reset Source: POWER-ON ✓

--- Test 2: Initialize Watchdog ---
Initializing IWDG: 2000ms timeout
Watchdog Active! Feeding every 1s...

[Feed 1/10] Tick: 1000ms ✓
[Feed 2/10] Tick: 2000ms ✓
...
[Feed 10/10] Tick: 10000ms ✓

--- Test 3: Trigger Reset ---
Stopping feed. System will reset in ~2s...
(SYSTEM RESETS)

===================================
   Watchdog Driver Test Suite    
===================================
Last Reset Source: WATCHDOG TIMEOUT ✓✓✓
=== All Tests PASSED ===
```

**Warning**: The test intentionally causes a system reset!

## Release Notes (2025-12)

### Enhancements (Golden Template Alignment)
- **Dependency Injection**: Added `Watchdog_Register()` for explicit handle management.
- **Fallback Safety**: Internal handle ensures backward compatibility.
- **Improved Calculation**: More robust prescaler selection logic.
- **Null Checks**: Added null pointer protection in `Watchdog_Feed()`.
- **Clean Stubs**: Graceful degradation when `HAL_IWDG_MODULE_ENABLED` is not defined.

### Breaking Changes
- None (backward compatible - registration is optional).
