#ifndef __KEY_DRIVER_H
#define __KEY_DRIVER_H

#ifdef __cplusplus
extern "C" {
#endif

#include "stm32f1xx_hal.h"
#include <stdbool.h>

/* ========================================= CONFIGURATION ========================================= */

/**
 * @brief Enable single key mode
 * @note  Set to 1 to enable single key functionality, 0 to disable
 */
#define USE_SINGLE_KEY        0

/**
 * @brief Enable matrix key mode
 * @note  Set to 1 to enable matrix keypad functionality, 0 to disable
 */
#define USE_MATRIX_KEY        1

/**
 * @brief Maximum number of single keys supported
 */
#define MAX_SINGLE_KEYS       0

/**
 * @brief Maximum number of matrix keypads supported
 */
#define MAX_MATRIX_KEYS       1

/**
 * @brief Default debounce time in milliseconds
 * @note  Recommended value: 10-50ms to filter out contact bounce
 */
#define KEY_DEFAULT_DEBOUNCE_TIME_MS  20

/**
 * @brief Default long press detection time in milliseconds
 * @note  Time threshold for detecting a long press
 */
#define KEY_DEFAULT_LONG_PRESS_TIME_MS 1000

/**
 * @brief Key driver configuration structure
 * @details This structure allows parameterized configuration of key behavior
 */
typedef struct {
    uint32_t debounce_time_ms;     /**< Debounce time in milliseconds */
    uint32_t long_press_time_ms;   /**< Long press detection time in milliseconds */
    bool auto_clear_events;        /**< Automatically clear events after reading */
} KeyConfig_t;

/**
 * @brief Get default key configuration
 * @return Default key configuration structure
 */
KeyConfig_t Key_GetDefaultConfig(void);

/* ========================================= DATA TYPES ========================================= */

/**
 * @brief Key state enumeration
 */
typedef enum {
    KEY_STATE_IDLE = 0,      /**< Key is not pressed and not being debounced */
    KEY_STATE_PRESSED = 1,   /**< Key is detected as pressed (after debounce) */
    KEY_STATE_RELEASED = 2,  /**< Key is detected as released (after debounce) */
    KEY_STATE_LONG_PRESSED = 3 /**< Key has been pressed for a long time */
} KeyState_t;

/**
 * @brief Key event enumeration
 */
typedef enum {
    KEY_EVENT_NONE = 0,           /**< No event */
    KEY_EVENT_PRESS = 1,          /**< Key pressed (after debounce) */
    KEY_EVENT_RELEASE = 2,        /**< Key released (after debounce) */
    KEY_EVENT_CLICK = 3,          /**< Key clicked (press followed by release) */
    KEY_EVENT_LONG_PRESS = 4,     /**< Long press detected */
    KEY_EVENT_LONG_RELEASE = 5    /**< Key released after a long press */
} KeyEvent_t;

/**
 * @brief Single key structure definition
 */
typedef struct {
    GPIO_TypeDef* port;        /**< GPIO port for the key */
    uint16_t pin;              /**< GPIO pin for the key */
    bool active_level;         /**< Active level: true for high, false for low */
    KeyState_t state;          /**< Current state of the key */
    KeyEvent_t event;          /**< Current event generated by the key */
    bool raw_state;            /**< Raw key state without debounce */
    bool last_raw_state;       /**< Previous raw key state */
    uint32_t press_time;       /**< Time when the key was pressed */
    uint32_t debounce_time;    /**< Time stamp for debounce */
    uint32_t long_press_time;  /**< Time stamp for long press detection */
} KeySingle_t;

/**
 * @brief Matrix keypad structure definition
 */
typedef struct {
    GPIO_TypeDef** row_ports;  /**< Array of GPIO ports for rows */
    uint16_t* row_pins;        /**< Array of GPIO pins for rows */
    GPIO_TypeDef** col_ports;  /**< Array of GPIO ports for columns */
    uint16_t* col_pins;        /**< Array of GPIO pins for columns */
    uint8_t rows;              /**< Number of rows in the matrix */
    uint8_t cols;              /**< Number of columns in the matrix */
    KeyState_t** key_states;   /**< 2D array of key states (NULL if not allocated) */
    KeyEvent_t** key_events;   /**< 2D array of key events (NULL if not allocated) */
} KeyMatrix_t;

/* ========================================= PUBLIC FUNCTIONS ========================================= */

/**
 * @brief Initialize key driver with default configuration
 * @details Configures GPIO pins and initializes key structures with default settings
 */
void Key_Init(void);

/**
 * @brief Initialize key driver with custom configuration
 * @details Configures GPIO pins and initializes key structures with custom settings
 * @param config Pointer to configuration structure (NULL to use default)
 */
void Key_InitWithConfig(KeyConfig_t *config);

/**
 * @brief Scan all keys
 * @details Updates key states and events based on GPIO readings
 * @note Should be called periodically in main loop or timer interrupt
 */
void Key_Scan(void);

/**
 * @brief Get the current state of a single key
 * @param key_id Index of the key (0 to MAX_SINGLE_KEYS-1)
 * @return Current key state
 */
KeyState_t Key_GetSingleState(uint8_t key_id);

/**
 * @brief Get the current event for a single key
 * @details This function also clears the event after reading
 * @param key_id Index of the key (0 to MAX_SINGLE_KEYS-1)
 * @return Current key event
 */
KeyEvent_t Key_GetSingleEvent(uint8_t key_id);

/**
 * @brief Check if a single key is currently pressed
 * @param key_id Index of the key (0 to MAX_SINGLE_KEYS-1)
 * @return true if key is pressed, false otherwise
 */
bool Key_IsSinglePressed(uint8_t key_id);

/**
 * @brief Get the current state of a matrix keypad key
 * @param matrix_id Index of the matrix keypad
 * @param row Row index of the key
 * @param col Column index of the key
 * @return Current key state
 */
KeyState_t Key_GetMatrixState(uint8_t matrix_id, uint8_t row, uint8_t col);

/**
 * @brief Get the current event for a matrix keypad key
 * @details This function also clears the event after reading
 * @param matrix_id Index of the matrix keypad
 * @param row Row index of the key
 * @param col Column index of the key
 * @return Current key event
 */
KeyEvent_t Key_GetMatrixEvent(uint8_t matrix_id, uint8_t row, uint8_t col);

/**
 * @brief Update key driver configuration at runtime
 * @param config Pointer to configuration structure with new values
 */
void Key_UpdateConfig(KeyConfig_t *config);

/**
 * @brief Test function for key driver
 * @details Initializes required peripherals and demonstrates key scanning
 */
void Key_Test(void);

void single_key_test(void);

#ifdef __cplusplus
}
#endif

#endif /* __KEY_DRIVER_H */
